shape1 = c.post*dH,
shape2 = c.post*(1-dH))
}
H <- vector()
DH <- vector()
for (j in 1:length(grid_eval)){
H[j] <- sum(lst.S*as.numeric(lst.X <= grid_eval[j]))
DH[j] <- sum(lst.betas*as.numeric(lst.times <= grid_eval[j]))
}
return(exp(-H))#-DH))
}
s.hat.sim <- function(num.sim, grid_eval, seed.start){
simulations <- matrix(nrow = length(grid_eval),
ncol = num.sim)
for (i in 1:num.sim){
simulations[, i] <- s.hat(grid_eval = grid_eval,
seed = seed.start + i)
}
return(simulations)
}
grid_eval <- seq(from = 0,
to = max(data$y),
by = 0.01)
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
max(data$y)
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
s.hat.mc <- s.hat.sim(num.sim = num.sim,
grid_eval = grid_eval,
seed.start = 456)
# Real Survival Function
real.surv <- to_vec(for (time in grid_eval) exp(-rate*time))
# Kaplan-Meier estimator
surv.object <- Surv(time = data$y,
event = data$exact)
fit1 <- survfit(formula = surv.object ~ 1,
data = data)
plot(fit1,
xlab = "Time",
ylab = "Overall survival probability",
col = "blue")
lines(grid_eval,
apply(s.hat.mc, 1, mean),
col = "red")
a
curve(exp(- a * x), add = TRUE)
# H_m evaluation
s.hat <- function(grid_eval, seed){
set.seed(seed)
lst.E <- rexp(n = m,
rate = 1)
lst.V <- to_vec(for (j in 1:m) sum(lst.E[1:j]))
lst.X <- runif(n = m,
min = 0,
max = tau)
##### SIMULATION OF CONTINUOUS PART #####
lst.S <- vector(length = m)
for (i in 1:m){
fun.xi <- function(s){
return(L(x = lst.X[i],
s = s)-lst.V[i])
}
if (fun.xi(s = tol) < 0){
break}
lst.S[i] <- uniroot(f = fun.xi,
lower = tol,
upper = 1)$root
}
lst.S[i:m] <- 0
##### SIMULATION OF DISCRETE PART #####
lst.betas <- vector()
for (it in 1:length(lst.times)){
t <- lst.times[it]
c.post <- cfun(t = t) + Y(data = data, t = t)
dH <- (0 + sum((data$y == t) & (data$exact == 1)))/c.post
lst.betas[it] <- rbeta(n = 1,
shape1 = c.post*dH,
shape2 = c.post*(1-dH))
}
H <- vector()
DH <- vector()
for (j in 1:length(grid_eval)){
H[j] <- sum(lst.S*as.numeric(lst.X <= grid_eval[j]))
DH[j] <- sum(lst.betas*as.numeric(lst.times <= grid_eval[j]))
}
return(exp(-H - DH))
}
s.hat.sim <- function(num.sim, grid_eval, seed.start){
simulations <- matrix(nrow = length(grid_eval),
ncol = num.sim)
for (i in 1:num.sim){
simulations[, i] <- s.hat(grid_eval = grid_eval,
seed = seed.start + i)
}
return(simulations)
}
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
s.hat.mc <- s.hat.sim(num.sim = num.sim,
grid_eval = grid_eval,
seed.start = 456)
# Kaplan-Meier estimator
surv.object <- Surv(time = data$y,
event = data$exact)
fit1 <- survfit(formula = surv.object ~ 1,
data = data)
plot(fit1,
xlab = "Time",
ylab = "Overall survival probability",
col = "blue")
lines(grid_eval,
apply(s.hat.mc, 1, mean),
col = "red")
library(survival)
library(comprehenr)
########## SIMULATE DATA ##########
sim.times <- function(d, n.obs, p.cens, r.min = 1, r.max = 2, seed = 123){
set.seed(seed)
# Number of censored times per group
n.cens <- round(n.obs*p.cens)
# Sample hazard rates uniformly between r.min and r.max
lst.rates <- runif(n = d,
min = r.min,
max = r.max)
# Initialize matrix of survival times
vec.times <- vector(length = d*n.obs)
vec.delta <- vector(length = d*n.obs)
vec.group <- vector(length = d*n.obs)
vec.rate <- vector(length = d*n.obs)
# Sample times from exponential model and censor a sample of them
for (r in 1:d){
set.seed(seed + r)
rate <- lst.rates[r]
lst.times <- rexp(n = n.obs, rate = rate)
lst.delta <- rep(1, n.obs)
lst.ind <- sample(x = 1:n.obs,
size = n.cens)
lst.times[lst.ind] <- pmin(lst.times[lst.ind], median(lst.times))
lst.delta[lst.ind] <- 0
a <- ((r-1)*n.obs+1)
b <- (r*n.obs)
vec.times[a:b] <- lst.times
vec.delta[a:b] <- lst.delta
vec.group[a:b] <- r
vec.rate[a:b] <- rate
}
mat.output <- matrix(nrow = (d*n.obs),
ncol = 4)
mat.output[, 1] <- vec.times
mat.output[, 2] <- vec.delta
mat.output[, 3] <- vec.group
mat.output[, 4] <- vec.rate
data <- data.frame(mat.output)
colnames(data) <- c("y", "exact", "group", "rate")
return(data)
}
########## PARAMETERS ##########
n.obs <- 5
p.cens <- 0
########## DATA SIMULATION ##########
data <- sim.times(d = 1, n.obs = n.obs, p.cens = p.cens)
rate <- unique(data[, 4])
data <- data[, c(1,2)]
m <- 1000
num.sim <- 1000
tol <- 1e-04
data.tmp <- aggregate(x = data,
by = list(data$y, data$exact),
FUN = length)
data.tmp.b <- data.tmp[(data.tmp$Group.2 == 1) & (data.tmp$y > 0), ]
lst.times <- unique(sort(data.tmp.b$Group.1))
# F.K. Algorithm
tau <- max(data$y)
a <- 1/mean(data$y)
Lambda <- function(t){
return(a*t)
}
cfun <- function(t){
return(1)
}
# At risk process
# (counting process for the subjects still alive at t)
Y <- function(data, t){
return(sum(data$y >= t))
}
# N function
# (counting process for the uncensored observations)
N <- function(data, t){
return(sum((data$y <= t) & (data$exact == 1)))
}
L <- function(x, s){
c <- cfun(t = x)
y <- Y(data = data, t = x)
f <- function(u){
return(c*((1-u)^(c+y-2))/u)
}
flt.i <- integrate(f = f,
lower = s,
upper = 1)$value
return(Lambda(tau)*flt.i)
}
# H_m evaluation
s.hat <- function(grid_eval, seed){
set.seed(seed)
lst.E <- rexp(n = m,
rate = 1)
lst.V <- to_vec(for (j in 1:m) sum(lst.E[1:j]))
lst.X <- runif(n = m,
min = 0,
max = tau)
##### SIMULATION OF CONTINUOUS PART #####
lst.S <- vector(length = m)
for (i in 1:m){
fun.xi <- function(s){
return(L(x = lst.X[i],
s = s)-lst.V[i])
}
if (fun.xi(s = tol) < 0){
break}
lst.S[i] <- uniroot(f = fun.xi,
lower = tol,
upper = 1)$root
}
lst.S[i:m] <- 0
##### SIMULATION OF DISCRETE PART #####
lst.betas <- vector()
for (it in 1:length(lst.times)){
t <- lst.times[it]
c.post <- cfun(t = t) + Y(data = data, t = t)
dH <- (0 + sum((data$y == t) & (data$exact == 1)))/c.post
lst.betas[it] <- rbeta(n = 1,
shape1 = c.post*dH,
shape2 = c.post*(1-dH))
}
H <- vector()
DH <- vector()
for (j in 1:length(grid_eval)){
H[j] <- sum(lst.S*as.numeric(lst.X <= grid_eval[j]))
DH[j] <- sum(lst.betas*as.numeric(lst.times <= grid_eval[j]))
}
return(exp(-H - DH))
}
s.hat.sim <- function(num.sim, grid_eval, seed.start){
simulations <- matrix(nrow = length(grid_eval),
ncol = num.sim)
for (i in 1:num.sim){
simulations[, i] <- s.hat(grid_eval = grid_eval,
seed = seed.start + i)
}
return(simulations)
}
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
s.hat.mc <- s.hat.sim(num.sim = num.sim,
grid_eval = grid_eval,
seed.start = 456)
# Kaplan-Meier estimator
surv.object <- Surv(time = data$y,
event = data$exact)
fit1 <- survfit(formula = surv.object ~ 1,
data = data)
plot(fit1,
xlab = "Time",
ylab = "Overall survival probability",
col = "blue")
lines(grid_eval,
apply(s.hat.mc, 1, mean),
col = "red")
curve(exp(- a * x), add = TRUE)
cfun <- function(t){
return(100)
}
# At risk process
# (counting process for the subjects still alive at t)
Y <- function(data, t){
return(sum(data$y >= t))
}
# N function
# (counting process for the uncensored observations)
N <- function(data, t){
return(sum((data$y <= t) & (data$exact == 1)))
}
L <- function(x, s){
c <- cfun(t = x)
y <- Y(data = data, t = x)
f <- function(u){
return(c*((1-u)^(c+y-2))/u)
}
flt.i <- integrate(f = f,
lower = s,
upper = 1)$value
return(Lambda(tau)*flt.i)
}
# H_m evaluation
s.hat <- function(grid_eval, seed){
set.seed(seed)
lst.E <- rexp(n = m,
rate = 1)
lst.V <- to_vec(for (j in 1:m) sum(lst.E[1:j]))
lst.X <- runif(n = m,
min = 0,
max = tau)
##### SIMULATION OF CONTINUOUS PART #####
lst.S <- vector(length = m)
for (i in 1:m){
fun.xi <- function(s){
return(L(x = lst.X[i],
s = s)-lst.V[i])
}
if (fun.xi(s = tol) < 0){
break}
lst.S[i] <- uniroot(f = fun.xi,
lower = tol,
upper = 1)$root
}
lst.S[i:m] <- 0
##### SIMULATION OF DISCRETE PART #####
lst.betas <- vector()
for (it in 1:length(lst.times)){
t <- lst.times[it]
c.post <- cfun(t = t) + Y(data = data, t = t)
dH <- (0 + sum((data$y == t) & (data$exact == 1)))/c.post
lst.betas[it] <- rbeta(n = 1,
shape1 = c.post*dH,
shape2 = c.post*(1-dH))
}
H <- vector()
DH <- vector()
for (j in 1:length(grid_eval)){
H[j] <- sum(lst.S*as.numeric(lst.X <= grid_eval[j]))
DH[j] <- sum(lst.betas*as.numeric(lst.times <= grid_eval[j]))
}
return(exp(-H - DH))
}
s.hat.sim <- function(num.sim, grid_eval, seed.start){
simulations <- matrix(nrow = length(grid_eval),
ncol = num.sim)
for (i in 1:num.sim){
simulations[, i] <- s.hat(grid_eval = grid_eval,
seed = seed.start + i)
}
return(simulations)
}
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
s.hat.mc <- s.hat.sim(num.sim = num.sim,
grid_eval = grid_eval,
seed.start = 456)
# Real Survival Function
real.surv <- to_vec(for (time in grid_eval) exp(-rate*time))
rate
# Kaplan-Meier estimator
surv.object <- Surv(time = data$y,
event = data$exact)
fit1 <- survfit(formula = surv.object ~ 1,
data = data)
plot(fit1,
xlab = "Time",
ylab = "Overall survival probability",
col = "blue")
lines(grid_eval,
apply(s.hat.mc, 1, mean),
col = "red")
curve(exp(- a * x), add = TRUE)
cfun <- function(t){
return(5)
}
# At risk process
# (counting process for the subjects still alive at t)
Y <- function(data, t){
return(sum(data$y >= t))
}
# N function
# (counting process for the uncensored observations)
N <- function(data, t){
return(sum((data$y <= t) & (data$exact == 1)))
}
L <- function(x, s){
c <- cfun(t = x)
y <- Y(data = data, t = x)
f <- function(u){
return(c*((1-u)^(c+y-2))/u)
}
flt.i <- integrate(f = f,
lower = s,
upper = 1)$value
return(Lambda(tau)*flt.i)
}
# H_m evaluation
s.hat <- function(grid_eval, seed){
set.seed(seed)
lst.E <- rexp(n = m, rate = 1)
lst.V <- to_vec(for (j in 1:m) sum(lst.E[1:j]))
lst.X <- runif(n = m,
min = 0,
max = tau)
##### SIMULATION OF CONTINUOUS PART #####
lst.S <- vector(length = m)
for (i in 1:m){
fun.xi <- function(s){
return(L(x = lst.X[i],
s = s)-lst.V[i])
}
if (fun.xi(s = tol) < 0){
break}
lst.S[i] <- uniroot(f = fun.xi,
lower = tol,
upper = 1)$root
}
lst.S[i:m] <- 0
##### SIMULATION OF DISCRETE PART #####
lst.betas <- vector()
for (it in 1:length(lst.times)){
t <- lst.times[it]
c.post <- cfun(t = t) + Y(data = data, t = t)
dH <- (0 + sum((data$y == t) & (data$exact == 1)))/c.post
lst.betas[it] <- rbeta(n = 1,
shape1 = c.post*dH,
shape2 = c.post*(1-dH))
}
H <- vector()
DH <- vector()
for (j in 1:length(grid_eval)){
H[j] <- sum(lst.S*as.numeric(lst.X <= grid_eval[j]))
DH[j] <- sum(lst.betas*as.numeric(lst.times <= grid_eval[j]))
}
return(exp(-H - DH))
}
s.hat.sim <- function(num.sim, grid_eval, seed.start){
simulations <- matrix(nrow = length(grid_eval),
ncol = num.sim)
for (i in 1:num.sim){
simulations[, i] <- s.hat(grid_eval = grid_eval,
seed = seed.start + i)
}
return(simulations)
}
grid_eval <- seq(from = 0,
to = max(data$y),
length = 500)
s.hat.mc <- s.hat.sim(num.sim = num.sim,
grid_eval = grid_eval,
seed.start = 456)
# Real Survival Function
real.surv <- to_vec(for (time in grid_eval) exp(-rate*time))
# Kaplan-Meier estimator
surv.object <- Surv(time = data$y,
event = data$exact)
fit1 <- survfit(formula = surv.object ~ 1,
data = data)
plot(fit1,
xlab = "Time",
ylab = "Overall survival probability",
col = "blue")
lines(grid_eval,
apply(s.hat.mc, 1, mean),
col = "red")
curve(exp(- a * x), add = TRUE)
x <- rexp(10^5)
plot(ecdf(x))
plot(1 - ecdf(x))
x <- rexp(10^5)
plot(1 - ecdf(x))
curve(1 - ecdf(x))
ecdf(x)
y <- rexp(10^5)
plot(function(x) ecdf(y)(x))
curve(function(x) ecdf(y)(x), 0 , 10 )
y <- rexp(10^5)
curve(function(x) ecdf(y)(x), 0 , 10 )
curve(ecdf(y)(x), 0 , 10 )
curve(1 - ecdf(y)(x), 0 , 10 )
y <- rexp(150)
curve(1 - ecdf(y)(x), 0 , 10 )
n <- 56
xn <- 76
sn <- 25
n <- 56
x_bar_n <- 76
x_n1 <- 90
sn <- 25
x_bar_n1 <- n / (n + 1) * x_bar_n + xn1 / (n + 1)
n <- 56
x_bar_n <- 76
x_n1 <- 90
sn <- 25
x_bar_n1 <- n / (n + 1) * x_bar_n + x_n1 / (n + 1)
x_bar_n1
x_n1
(n + 1)
s_n <- 25
x_bar_n1 <- n / (n + 1) * x_bar_n + x_n1 / (n + 1)
n * (sn + x_bar_n^2
)
n * (sn + x_bar_n^2) + x_n1^2
s_n1 = (n * (sn + x_bar_n^2) + x_n1^2) / (n + 1) - x_bar_n1^2
s_n1
x_bar_n1
x_bar_n1^2
76.25^2
s_n1 = (n * (sn + x_bar_n^2) + x_n1^2) / (n + 1) - x_bar_n1^2
s_n1
n / (n + 1) * s_n + n * (x_bar_n1 - x_bar_n)^2
(x_bar_n1 - x_bar_n)^2
s_n1 = (n * (sn + x_bar_n^2) + x_n1^2) / (n + 1) - x_bar_n1^2
n / (n + 1) * s_n + n * (x_bar_n1 - x_bar_n)^2
